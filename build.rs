use std::{env, fs, path::Path};

use postgres::{Client, NoTls, Row};

fn main() {
    dotenvy::dotenv().ok();

    // === iso_country codegen: ===
    let out_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not found");
    // Get DB info from .env variables for connection
    let db_host = env::var("DB_HOST").expect("DB_HOST not found");
    let db_port = env::var("DB_PORT").expect("DB_PORT not found");
    let db_username = env::var("DB_USERNAME").expect("DB_USERNAME not found");
    let db_password = env::var("DB_PASSWORD").expect("DB_PASSWORD not found");
    let db_name = env::var("DB_NAME").expect("DB_NAME not found");

    let db_url = if db_host.starts_with('/') {
        format!(
            "postgresql://{}:{}@{}/{}?host={}&port={}",
            db_username, db_password, "localhost", db_name, db_host, db_port
        )
    } else {
        format!(
            "postgresql://{}:{}@{}:{}/{}",
            db_username, db_password, db_host, db_port, db_name
        )
    };
    let mut client = Client::connect(&db_url, NoTls).expect("Could not connect to Postgres");

    // Query all rows from iso_country and emit them as Rust code for a const [IsoCountry; N]
    let static_out_path =
        Path::new(&out_dir).join("src/domain/country/repository/iso_country_static_gen.rs");

    let rows = client
        .query(
            "SELECT country_code, country_alpha2, country_alpha3, country_eng_name, country_currency, \
                    phone_prefix, country_flag, is_country, country_primary_language \
             FROM iso_country ORDER BY country_code",
            &[],
        )
        .expect("Failed to query iso_country");

    let repo_body = gen_country_static_code(&rows);
    fs::write(&static_out_path, repo_body).expect("Unable to write iso_country_static_gen.rs");

    // === iso_country_subdivision codegen: ===
    let static_subdiv_path = Path::new(&out_dir)
        .join("src/domain/country_subdivision/repository/iso_country_subdivision_static_gen.rs");

    let subdivision_rows = client
        .query(
            "SELECT subdivision_id, country_code, subdivision_code, subdivision_name, subdivision_type \
             FROM iso_country_subdivision ORDER BY subdivision_id",
            &[],
        )
        .expect("Failed to query iso_country_subdivision");

    let suburb_body = gen_country_subdivision_static_code(&subdivision_rows);
    fs::write(&static_subdiv_path, suburb_body)
        .expect("Unable to write iso_country_subdivision_static_gen.rs");

    // === build_info.rs codegen: ===
    // Get project name and version from environment variables set by Cargo
    let pkg_name = env::var("CARGO_PKG_NAME").unwrap_or_else(|_| "unknown".to_string());
    let pkg_version = env::var("CARGO_PKG_VERSION").unwrap_or_else(|_| "unknown".to_string());

    // Use chrono to get the current UTC datetime (build time)
    let build_time = chrono::Utc::now();

    // Read environment variable for dep versions, output by Cargo, via cargo metadata.
    // Use cargo_metadata to collect dependencies & versions
    let deps = get_lib_version_map().unwrap();

    let dest_path = Path::new(&out_dir).join("src/build_info.rs");
    let mut f = File::create(&dest_path).expect("Unable to create build_info.rs");

    // Write struct and impls at the top of build_info.rs
    let libs_count: usize = deps.list.len();

    let prelude = format!(
        r#"// autogenerated metadata - do not edit!
#[derive(Debug)]
pub struct LibVersion {{
    pub name: &'static str,
    pub version: &'static str,
}}

impl LibVersion {{
    pub fn get_name(&self) -> &'static str {{
        self.name
    }}
    pub fn get_version(&self) -> &'static str {{
        self.version
    }}
}}

pub struct LibVersionMap {{
    pub list: &'static [LibVersion],
}}

impl LibVersionMap {{
    pub fn get(&self, name: &str) -> Option<&LibVersion> {{
        self.list.iter().find(|v| v.get_name() == name)
    }}
}}

/// AUTO-GENERATED BY build.rs
pub const PROJECT_NAME: &str = {pkg_name:?};
pub const PROJECT_VERSION: &str = {pkg_version:?};
pub const BUILD_TIME_UTC: &str = "{}";
pub const LIB_VERSIONS: [LibVersion; {libs_count}] = ["#,
        build_time.to_rfc3339()
    );
    writeln!(f, "{}", prelude).expect("Failed to write build_info.rs prelude");

    for dep in deps.list.iter() {
        writeln!(
            f,
            "    LibVersion {{ name: {:?}, version: {:?} }},",
            dep.name, dep.version
        )
        .expect("Failed to write dep entry");
    }
    writeln!(f, "];").expect("Failed to finish LIB_VERSIONS array");

    // Write a const LIB_VERSION_MAP as well
    writeln!(
        f,
        "pub const LIB_VERSION_MAP: LibVersionMap = LibVersionMap {{ list: &LIB_VERSIONS }};"
    )
    .expect("Failed to write LIB_VERSION_MAP const");
}

/// Formats a Rust 'static str literal (with proper escaping).
fn literal_str(s: &str) -> String {
    let s = s.replace('\\', "\\\\").replace('\"', "\\\"");
    format!("\"{}\"", s)
}

/// Generate Rust code for the static ISO country table and lookup PHF maps.
fn gen_country_static_code(rows: &[Row]) -> String {
    let mut countries = String::new();
    let mut code_keyvals = String::new();
    let mut alpha2_keyvals = String::new();
    let mut alpha3_keyvals = String::new();

    for (i, row) in rows.iter().enumerate() {
        let country_code: i32 = row.get(0);
        let country_alpha2: String = row.get(1);
        let country_alpha3: String = row.get(2);
        let country_eng_name: String = row.get(3);
        let country_currency: i32 = row.get(4);
        let phone_prefix: String = row.get(5);
        let country_flag: String = row.get(6);
        let is_country: bool = row.get(7);
        let country_primary_language: i32 = row.get(8);

        let s = format!(
            "    IsoCountryStatic {{
        country_code: {country_code},
        country_alpha2: {alpha2},
        country_alpha3: {alpha3},
        country_eng_name: {eng_name},
        country_currency: {country_currency},
        phone_prefix: {phone_prefix},
        country_flag: {country_flag},
        is_country: {is_country},
        country_primary_language: {country_primary_language},
    }},
",
            country_code = country_code,
            alpha2 = literal_str(&country_alpha2),
            alpha3 = literal_str(&country_alpha3),
            eng_name = literal_str(&country_eng_name),
            country_currency = country_currency,
            phone_prefix = literal_str(&phone_prefix),
            country_flag = literal_str(&country_flag),
            is_country = is_country,
            country_primary_language = country_primary_language
        );
        countries.push_str(&s);

        code_keyvals.push_str(&format!(
            "{code}i32 => &ISO_COUNTRIES[{idx}],\n",
            code = country_code,
            idx = i
        ));
        alpha2_keyvals.push_str(&format!(
            "{alpha2} => &ISO_COUNTRIES[{idx}],\n",
            alpha2 = literal_str(&country_alpha2),
            idx = i
        ));
        alpha3_keyvals.push_str(&format!(
            "{alpha3} => &ISO_COUNTRIES[{idx}],\n",
            alpha3 = literal_str(&country_alpha3),
            idx = i
        ));
    }

    let n_countries = rows.len();

    format!(
        r#"// This file is @generated automatically by build.rs; do not edit manually.

use crate::domain::country::iso_country::IsoCountryStatic;
use phf::{{phf_map, Map}};

/// All ISO country rows statically loaded at compile time.
pub static ISO_COUNTRIES: [IsoCountryStatic; {len}] = [
{countries}
];

/// PHF static maps for fast lookup by code, alpha2, alpha3.
pub static BY_CODE: Map<i32, &'static IsoCountryStatic> = phf_map! {{
{code_keyvals}
}};

pub static BY_ALPHA2: Map<&'static str, &'static IsoCountryStatic> = phf_map! {{
{alpha2_keyvals}
}};

pub static BY_ALPHA3: Map<&'static str, &'static IsoCountryStatic> = phf_map! {{
{alpha3_keyvals}
}};

/// Lookup by numeric country code.
pub fn by_code(code: i32) -> Option<&'static IsoCountryStatic> {{
    BY_CODE.get(&code).copied()
}}

/// Lookup by country alpha-2 code.
pub fn by_alpha2(alpha2: &str) -> Option<&'static IsoCountryStatic> {{
    BY_ALPHA2.get(alpha2).copied()
}}

/// Lookup by country alpha-3 code.
pub fn by_alpha3(alpha3: &str) -> Option<&'static IsoCountryStatic> {{
    BY_ALPHA3.get(alpha3).copied()
}}
"#,
        len = n_countries,
        countries = countries,
        code_keyvals = code_keyvals,
        alpha2_keyvals = alpha2_keyvals,
        alpha3_keyvals = alpha3_keyvals
    )
}

// Generate Rust code for the static ISO country subdivision table and lookup PHF maps.
fn gen_country_subdivision_static_code(rows: &[Row]) -> String {
    let mut subdivisions = String::new();
    let mut id_keyvals = String::new();
    let mut country_map: std::collections::BTreeMap<i32, Vec<usize>> =
        std::collections::BTreeMap::new();

    for (i, row) in rows.iter().enumerate() {
        let subdivision_id: i32 = row.get(0);
        let country_code: i32 = row.get(1);
        let subdivision_code: String = row.get(2);
        let subdivision_name: String = row.get(3);
        let subdivision_type: Option<String> = row.get(4);

        let type_expr = match &subdivision_type {
            Some(s) => format!("Some({})", literal_str(s)),
            None => "None".to_string(),
        };
        subdivisions.push_str(&format!(
            "    IsoCountrySubdivisionStatic {{
        subdivision_id: {sub_id},
        country_code: {country_code},
        subdivision_code: {sub_code},
        subdivision_name: {sub_name},
        subdivision_type: {type_expr},
    }},
",
            sub_id = subdivision_id,
            country_code = country_code,
            sub_code = literal_str(&subdivision_code),
            sub_name = literal_str(&subdivision_name),
            type_expr = type_expr,
        ));
        id_keyvals.push_str(&format!(
            "{sub_id}i32 => &ISO_COUNTRY_SUBDIVISIONS[{index}],\n",
            sub_id = subdivision_id,
            index = i,
        ));
        country_map.entry(country_code).or_default().push(i);
    }

    // Build country_code => &[...] mappings with static arrays
    let mut country_slices = String::new();
    let mut country_keys = String::new();
    for (cc, entries) in &country_map {
        let slice_name = format!("CC_{}_SUBS", cc);
        let elems = entries
            .iter()
            .map(|i| format!("&ISO_COUNTRY_SUBDIVISIONS[{i}]", i = i))
            .collect::<Vec<_>>()
            .join(", ");
        country_slices.push_str(&format!(
            "pub static {slice_name}: [&IsoCountrySubdivisionStatic; {len}] = [{}];\n",
            elems,
            slice_name = slice_name,
            len = entries.len()
        ));
        country_keys.push_str(&format!(
            "{cc}i32 => &{slice_name} as &'static [&IsoCountrySubdivisionStatic],\n",
            cc = cc,
            slice_name = slice_name
        ));
    }

    let n_subdivisions = rows.len();

    format!(
        r#"// This file is @generated automatically by build.rs; do not edit manually.

use crate::domain::country_subdivision::iso_country_subdivision::IsoCountrySubdivisionStatic;
use phf::{{phf_map, Map}};

/// All ISO country subdivision rows statically loaded at compile time.
pub static ISO_COUNTRY_SUBDIVISIONS: [IsoCountrySubdivisionStatic; {len}] = [
{subdivisions}
];

{country_slices}
/// PHF static maps for fast lookup.
pub static BY_ID: Map<i32, &'static IsoCountrySubdivisionStatic> = phf_map! {{
{id_keyvals}
}};

pub static BY_COUNTRY_CODE: Map<i32, &'static [&'static IsoCountrySubdivisionStatic]> = phf_map! {{
{country_keys}
}};

pub fn by_id(id: i32) -> Option<&'static IsoCountrySubdivisionStatic> {{
    BY_ID.get(&id).copied()
}}
pub fn by_country_code(code: i32) -> &'static [&'static IsoCountrySubdivisionStatic] {{
    BY_COUNTRY_CODE.get(&code).copied().unwrap_or(&[])
}}
"#,
        len = n_subdivisions,
        subdivisions = subdivisions,
        id_keyvals = id_keyvals,
        country_slices = country_slices,
        country_keys = country_keys
    )
}

use std::fs::File;
use std::io::Write;

struct LibVersion {
    name: &'static str,
    version: &'static str,
}

impl LibVersion {
    fn get_name(&self) -> &'static str {
        self.name
    }
    fn get_version(&self) -> &'static str {
        self.version
    }
}

struct LibVersionMap {
    list: &'static [LibVersion],
}

impl LibVersionMap {
    fn get(&self, name: &str) -> Option<&LibVersion> {
        self.list.iter().find(|&v| v.get_name() == name)
    }
}

fn get_lib_version_map() -> Option<LibVersionMap> {
    use std::process::Command;
    // Remove --no-deps so we get all resolved dependency versions from Cargo.lock
    let output = Command::new("cargo")
        .args(&["metadata", "--format-version", "1"])
        .output()
        .ok()?;
    if !output.status.success() {
        return None;
    }
    let metadata: serde_json::Value = serde_json::from_slice(&output.stdout).ok()?;
    let pkgs = metadata.get("packages")?.as_array()?;
    let resolve = metadata.get("resolve")?;
    let root_id = resolve.get("root")?.as_str()?;
    let root_pkg = pkgs
        .iter()
        .find(|pkg| pkg.get("id").and_then(|id| id.as_str()) == Some(root_id))?;

    // Get only dependencies specified in Cargo.toml (root package)
    let deps = root_pkg.get("dependencies")?.as_array()?;

    // Dependency names as a Vec for quick lookup
    let mut dep_names = Vec::new();
    for dep in deps {
        if let Some(dep_name) = dep.get("name").and_then(|n| n.as_str()) {
            dep_names.push(dep_name);
        }
    }

    // Now find all resolved packages (avoid root package itself), matching names from Cargo.toml
    let mut dep_vec = Vec::new();
    for pkg in pkgs {
        let pkg_name = pkg.get("name").and_then(|n| n.as_str())?;
        let pkg_id = pkg.get("id").and_then(|id| id.as_str())?;
        if pkg_id == root_id {
            continue; // skip root crate itself
        }
        if dep_names.contains(&pkg_name) {
            let version = pkg.get("version")?.as_str()?;
            dep_vec.push(LibVersion {
                name: Box::leak(pkg_name.to_owned().into_boxed_str()),
                version: Box::leak(version.to_owned().into_boxed_str()),
            });
        }
    }
    dep_vec.sort_by(|a, b| a.name.cmp(b.name));

    // leak dep_vec into static memory, yielding a &'static [LibVersion]
    let static_dep_slice: &'static [LibVersion] = {
        let boxed: Box<[LibVersion]> = dep_vec.into_boxed_slice();
        Box::leak(boxed)
    };

    Some(LibVersionMap {
        list: static_dep_slice,
    })
}

